#line 10 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip writeblock[T]
  connector io
    pin inp : %<T
{
}

#line 19 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip readblock[T]
  connector io
    pin inp: %>T
{
}


#line 29 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip sink[T]
  connector io
    pin inp : %<T
{
  while true do
    var x = read (io.inp);
    C_hack::ignore (x);
  done
}

#line 42 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip source[T] (a:T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, a);
  done
}

#line 53 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip source_from_list[T] (a:list[T])
  connector io
    pin out: %>T
{
  for y in a perform write (io.out,y);
}

#line 63 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip function[D,C] (f:D->C)
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
    var y = f x;
    write (io.out, y);
  done
}

#line 78 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip buffer [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    var x = read io.inp;
    write (io.out, x);
  done
}

#line 92 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip debug_buffer [T with Str[T]] (tag:string)
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    println$ "Debug buffer [" + tag + "] READ";
    var x = read io.inp;
    println$ "Debug buffer [" + tag + "] read " + x.str;
    write (io.out, x);
    println$ "Debug buffer [" + tag + "] written " + x.str;
  done
}

#line 109 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip oneshot [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  var x = read io.inp;
  write (io.out, x);
}

#line 121 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip store[T] (p:&T)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    p <- x;
  done
}

#line 134 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip fetch[T] (p:&T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, *p);
  done
}

#line 147 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip debug_sink [T with Str[T]] (s:string)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    println$ "Debug sink ["+s+"] "+x.str;
  done
}


#line 163 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip latch[T]
  connector io
    pin inp: %<T
    pin out: %>T
{
   var x = read io.inp;
   device w = fetch &x;
   device r = store &x;
   circuit
     wire io.inp to r.inp
     wire io.out to w.out
   endcircuit
}

#line 184 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip serialise_chan_list[T] (a: list[%<T])
 connector io
   pin out: %>T
{
  while true do
    var current = a;
next:>
    match current with
    | Cons (h,t) =>
      var x = read h;
      write (io.out, x);
      current = t;
      goto next;
    | Empty => ;
    endmatch;
  done
}

typedef iopair_t[D,C] = (inp: %<D, out: %>C);
typedef iochip_t[D,C] = iopair_t[D,C] -> 1 -> 0;

// NOTE: this is currently a one-shot!
// .. Well sort of!
// It can do multiple reads if its first chip
// cycles. If the pipeline drops dead, it will
// not be reuable.
//
// To be reusable, components should not return,
// instead loop back to reading without writing.

chip pipeline_list[T] (a: list[iochip_t[T,T]])
  connector io
    pin inp: %<T
    pin out: %>T
{
  proc aux (lst:list[iochip_t[T,T]]) (inp: %<T) {
    match lst with
    | h1 ! h2 ! tail =>
      var inchan,outchan = mk_ioschannel_pair[T]();
      spawn_fthread$  h1 (inp=inp, out=outchan);
      aux (h2!tail) inchan;
    | h1 ! _ =>
      spawn_fthread$  h1 (inp=inp, out=io.out);
    endmatch;
  }
  aux a io.inp;
}

// This loops, but only by repeatedly spawning
// the alternative set. The alternatives are restricted
// to a single read on each iteration. The chips are
// respawned because they might be locked up, in which
// case the whole thing locks up.
//
// NOTE: if one of the alternatives starts, and does not
// read the input, everything locks up. This is because
// the implementation ACTUALLY progresses serially.
//
// this COULD be fixed by adding a buffer to the front of
// each. Actually better, add a one shot source based
// on the input.
chip tryall_list[D,C with Str[D]] (a: list[iochip_t[D,C]])
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
//println$ "Tryall read " + x.str;
    for h in a do
      var lin,lout = mk_ioschannel_pair[D]();
      spawn_fthread (h (inp=lin, out=io.out));
      write (lout,x);
    done
  done
}

