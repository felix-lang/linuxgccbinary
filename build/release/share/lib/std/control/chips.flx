#line 9 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip writeblock[T]
  connector io
    pin inp : %<T
{
}

#line 18 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
  union lsexpr[T,L] = | Leaf of T | Tree of L * list[lsexpr[T,L]];
chip readblock[T]
  connector io
    pin inp: %>T
{
}


#line 29 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip sink[T]
  connector io
    pin inp : %<T
{
  while true do
    var x = read (io.inp);
    C_hack::ignore (x);
  done
}

#line 42 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip source[T] (a:T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, a);
  done
}

#line 54 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip function[D,C] (f:D->C)
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
    var y = f x;
    write (io.out, y);
  done
}

#line 69 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip buffer [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    var x = read io.inp;
    write (io.out, x);
  done
}

#line 83 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip debug_buffer [T with Str[T]] (tag:string)
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    var x = read io.inp;
    println$ "Debug buffer [" + tag + "] " + x.str;
    write (io.out, x);
  done
}

#line 98 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip oneshot [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  var x = read io.inp;
  write (io.out, x);
}

#line 110 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip store[T] (p:&T)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    p <- x;
  done
}

#line 123 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip fetch[T] (p:&T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, *p);
  done
}

#line 136 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip debug_sink [T with Str[T]] (s:string)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    println$ "Debug sink ["+s+"] "+x.str;
  done
}


#line 152 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip latch[T]
  connector io
    pin inp: %<T
    pin out: %>T
{
   var x = read io.inp;
   device w = fetch &x;
   device r = store &x;
   circuit
     wire io.inp to r.inp
     wire io.out to w.out
   endcircuit
}

#line 173 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip serialise_chan_list[T] (a: list[%<T])
 connector io
   pin out: %>T
{
  while true do
    var current = a;
next:>
    match current with
    | Cons (h,t) =>
      var x = read h;
      write (io.out, x);
      current = t;
      goto next;
    | Empty => ;
    endmatch;
  done
}

typedef iopair_t[D,C] = (inp: %<D, out: %>C);
typedef iochip_t[D,C] = iopair_t[D,C] -> 1 -> 0;

// NOTE: this is currently a one-shot!
chip pipeline_list[T] (a: list[iochip_t[T,T]])
  connector io
    pin inp: %<T
    pin out: %>T
{
  proc aux (lst:list[iochip_t[T,T]]) (inp: %<T) {
    match lst with
    | h1 ! h2 ! tail =>
      var inchan,outchan = mk_ioschannel_pair[T]();
      spawn_fthread$  h1 (inp=inp, out=outchan);
      aux (h2!tail) inchan;
    | h1 ! _ =>
      spawn_fthread$  h1 (inp=inp, out=io.out);
    endmatch;
  }
  aux a io.inp;
}

// NOTE: this is currently a one-shot!
chip tryall_list[D,C with Str[D]] (a: list[iochip_t[D,C]])
  connector io
    pin inp: %<D
    pin out: %>C
{
  // get some input and start a source writing it
//println$ "Try all, reading value";
  var x = read io.inp;
//println$ "Try all, got value " + x.str;
  // now, start each device in turn, connected to
  // the source and output
//println$ "Try all writing to " + a.len.str " chips";
var n = 0;
  for h in a do
//println$ "Tryall, making channels and spawning fibre #"+n.str;
    var lin,lout = mk_ioschannel_pair[D]();
    spawn_fthread (h (inp=lin, out=io.out));
//println$ "Tryall, writing value to fibre";
    write (lout,x);
    ++n;
  done
}

