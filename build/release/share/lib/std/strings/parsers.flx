#line 301 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
struct Buffer
{
  sp: StringPiece;
  pos: int;

  fun atend => self.pos >= self.sp.len.int;

  fun get =>
    if self.atend then char ""
    else (self.sp.data) . (self.pos)
  ;

  proc next {
    if not self*.atend do
      pre_incr self.pos;
    done
  }

  fun advanced =>
    if self.atend then self
    else Buffer (self.sp, self.pos + 1)
  ;
}

ctor Buffer (p:&string) =>
  Buffer (p.StringPiece,0)
;

instance Str[Buffer] {
  fun str (b:Buffer) => "@"+b.pos.str;
}

// hack, ignore underlying data.. FIXME
instance Eq[Buffer] {
  fun == (a:Buffer, b:Buffer) => a.pos == b.pos;
}

#line 341 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"

///////////////////// capture pipeline lsexpr
include "std/datatype/lsexpr";

typedef lsexpr_t = LS_expr::lsexpr[string,string];
instance Str[lsexpr_t] {
  fun str (x:lsexpr_t) =>
     match x with
      | Leaf a => str a
      | Tree (a,b) => str a + "(" + List::catmap ","  (str of lsexpr_t) b  + ")"
    ;
}
open Str[lsexpr_t];

instance Eq[lsexpr_t] {
  fun ==: lsexpr_t * lsexpr_t -> bool=
  | Leaf a, Leaf b => a == b
  | Tree (a,x), Tree (b,y) => a == b and x == y
  ;
}

typedef ll_t = list[lsexpr_t];

// parser SHIFT action
gen push_entry (first: Buffer * ll_t, last: Buffer) : Buffer * ll_t =
{
   var lst = first.1;
   var b0 = first.0;
   var sp = b0.sp;
   var s = sp.string;
   var p0 = b0.pos;
   var p1 = last.pos;
   var lexeme = sp.[p0..<p1].string;
   //println$ "Lexeme = '" + lexeme+"'";
   var entry = LS_expr::Leaf[string,string] lexeme;
   var newstate = Cons (entry, lst);
   return last, newstate;
}

gen skip_entry (first: Buffer * ll_t, last: Buffer) : Buffer * ll_t =
{
  return last, first.1;
}

#line 388 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip match_string (s:string)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
nextmatch:>
  var b = read io.inp;
  for i in 0..< s.len.int do
    if s.[i] != b.get goto nextmatch;
    b&.next;
  done
  write (io.out, b);
  goto nextmatch;
}

#line 405 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip match_white
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  while true do
    var b = read io.inp;
    while not b.atend and b.get <= char ' ' perform b&.next;
    write (io.out,b);
  done
}

#line 420 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip match_regex (r:RE2)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  while true do
    var b = read io.inp;
//println$ "Match regex " + r.str;
    var matched = varray[StringPiece] (1uz,StringPiece());
    var result = Match(r,b.sp,b.pos,ANCHOR_START,matched.stl_begin,1);
//println$ "Match result " + result.str;
    if result do
//println$ "Matched OK, match len = " + matched.0.len.str;
      var b2 = Buffer (b.sp,b.pos+matched.0.len.int);
//println$ "Writing buffer = " + b2.str;
      write(io.out,b2);
    done
  done
}

#line 444 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
device cident_matcher = match_regex (RE2 "[A-Za-z][A-Za-z0-9_]*");

#line 450 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
device decimal_integer_matcher = match_regex (RE2 "[0-9]+");

#line 456 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip match_string_literal
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
restart:>
  var b = read io.inp;
  if b.atend goto restart; // end of data
  var leadin = b.get;
//println$ "string literal matcher got char " + leadin.str;
  if not (leadin in (char '"', char "'")) goto restart;
//println$ "Got valid string start .. ";
  b&.next;
  if b.atend goto restart;
  var ch = b.get;
  while ch != leadin do
    b&.next;
    if b.atend goto restart;
    ch = b.get;
    if ch == char "\n" goto restart; // end of line
  done
  b&.next;
  io.out `write` b;
  goto restart;
}

chip match_string_literal_backquote
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
restart:>
  var b = read io.inp;
  if b.atend goto restart; // end of data
  var leadin = b.get;
//println$ "string literal matcher got char " + leadin.str;
  if leadin != char '`' goto restart;
//println$ "Got valid string start .. ";
  b&.next;
  if b.atend goto restart;
  var ch = b.get;
  while ch != leadin do
    b&.next;
    if b.atend goto restart;
    ch = b.get;
    if ch == char "\n" goto restart; // end of line
  done
  b&.next;
  io.out `write` b;
  goto restart;
}


#line 531 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
typedef pardat_t[B,T] = B * T;

chip leaf_capture[B,T]
  (
    scan: iochip_t[B,B],
    newstate: pardat_t[B,T] * B -> pardat_t[B,T]
  )
  connector io
    pin inp: %<pardat_t[B,T]
    pin out: %>pardat_t[B,T]
{
while true do
  var x = read io.inp;
  noinline proc handler (var x: pardat_t[B,T]) () {
    var b,pd = x;
    var rin,win= mk_ioschannel_pair[B]();
    var rout,wout= mk_ioschannel_pair[B]();
    spawn_fthread (scan (inp=rin,out=wout));
    write(win,b);
    var b2 = read rout; // this can block forever if scan fails
    var s = newstate ((b,pd),b2);
    write (io.out,s);
  }
  var y = handler x;
  spawn_fthread y;
done
}

fun string_parser (s:string) =>
  leaf_capture (match_string s,push_entry)
;

#line 567 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip epsilon[T]
  connector io
   pin inp: %<T
   pin out: %>T
{
  while true do
    var x = read io.inp;
    write (io.out, x);
  done
}
#line 582 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"
chip optional[T] (p:iochip_t[T,T])
  connector io
    pin inp: %<T
    pin out: %>T
{
  device both = tryall_list ([
    p,
    epsilon[T]
  ]);
  circuit
    wire io.inp to both.inp
    wire io.out to both.out
  endcircuit
}

#line 599 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"

chip oneormore_matcher[T] (A:iochip_t[T,T])
connector chans
  pin inp: %<T
  pin out: %>T
{
 device As = oneormore_matcher A;
 device As2 = pipeline_list (A,As).list;
 device Ass = tryall_list (A, As2).list;
 circuit
   wire chans.inp to Ass.inp
   wire chans.out to Ass.out
 endcircuit
}

#line 616 "/home/travis/build/felix-lang/felix/src/packages/chips.fdoc"

chip zeroormore_matcher[T] (A:iochip_t[T,T])
connector chans
  pin inp: %<T
  pin out: %>T
{
 device As = oneormore_matcher A;
 device Ass = tryall_list (epsilon[T], As).list;
 circuit
   wire chans.inp to Ass.inp
   wire chans.out to Ass.out
 endcircuit
}

